package com.incture.accpay.services;

import javax.persistence.EntityManager;
import javax.persistence.FlushModeType;

import com.incture.accpay.entities.APSmSeqNumberDo;


public class SequenceNumberGen {

	private static SequenceNumberGen sequenceNumberGenerator;
	
	APSmSeqNumberDo sequenceNumbersDo =null;
	private static int oldRunningNumber=0;
	private static String oldRefCode="";
	private SequenceNumberGen() {
	}

	public static synchronized SequenceNumberGen getInstance() {
		return sequenceNumberGenerator == null ? sequenceNumberGenerator = new SequenceNumberGen()
				: sequenceNumberGenerator;
	}

	/**
	 * Generates a code in CCCCXXYYYYMMNNNN format, where CCCC is Company Code,
	 * XX is Transaction Type, YYYY is year, MM is Month, NNNN is the number
	 * generated by this function. Input field <code>referenceCode</code> is
	 * CCCCXXYYYYMM and <code>noOfDigits</code> indicate size of NNNN. Function
	 * uses a variable of hash map data structure with application scope, where
	 * referenceCode parameter is the key and running number(sequential,
	 * incremented by 1, starting from 0) is the value. Function is thread-safe,
	 * map variable is lazy loaded once, and value persist to relevant table in
	 * CEDB on every request.
	 */
	public synchronized String getNextSeqNumber(String referenceCode,
			Integer noOfDigits, EntityManager entityManager) {
		
		
		sequenceNumbersDo = entityManager.find(APSmSeqNumberDo.class, referenceCode);
		
		int runningNumber;
		if(sequenceNumbersDo!=null)
		{
			entityManager.setFlushMode(FlushModeType.COMMIT);
			entityManager.refresh(sequenceNumbersDo);
			runningNumber = updateRecord(sequenceNumbersDo, entityManager);
			if(oldRunningNumber==runningNumber && oldRefCode.equals(referenceCode)){//to avoid duplicates
				sequenceNumbersDo = entityManager.find(APSmSeqNumberDo.class, referenceCode);
				runningNumber = updateRecord(sequenceNumbersDo, entityManager);
			}
		}
		else
		{
			runningNumber = pushRecord(referenceCode, entityManager);
		}
		oldRunningNumber=runningNumber;
		oldRefCode = referenceCode;
		return buildSeqNumber(referenceCode, noOfDigits, runningNumber);
	}

	private String buildSeqNumber(String referenceCode, Integer noOfDigits,
			int runningNumber) {
		StringBuffer sb = new StringBuffer(noOfDigits);
		sb.append(runningNumber);
		int noOfPads = noOfDigits - sb.length();
		// TODO: decide what to do if noOfPads is negative
		while (noOfPads-- > 0) {
			sb.insert(0, '0');
		}
		sb.insert(0, referenceCode);
		return sb.toString();
	}

	private int pushRecord(String referenceCode, EntityManager entityManager) {
		APSmSeqNumberDo sequenceNumbersDo = new APSmSeqNumberDo(
				referenceCode, 1);
		// NOTE: Hard coding to zero
		entityManager.persist(sequenceNumbersDo);
		return sequenceNumbersDo.getRunningNumber();
	}

	private int updateRecord(APSmSeqNumberDo sequenceNumbersDo, EntityManager entityManager) {
		int runningnumber=0;
		sequenceNumbersDo.setRunningNumber(sequenceNumbersDo.getRunningNumber() + 1);

		/**Code modified by Abhilash on 17/Oct/2013 to resolve the concurrent requests 
		 * assigned same sequence number.
		 * Modifications starts here
		 */
        entityManager.persist(sequenceNumbersDo);
		entityManager.flush();
		entityManager.refresh(sequenceNumbersDo);
		APSmSeqNumberDo retDto1=entityManager.find(APSmSeqNumberDo.class, sequenceNumbersDo.getReferenceCode());
		if(retDto1!=null){
			runningnumber=retDto1.getRunningNumber();
		}
		/**
		 * Code modifications by Abhilash ends here
		 */
		return runningnumber;
	}
}